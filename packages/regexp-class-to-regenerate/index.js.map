{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["///<reference path=\"./regenerate.d.ts\"/>\n\nimport {\n\tParserEventEmitter,\n\tParserEventEmitterEvent,\n} from 'regexp-parser-event';\nimport { EnumTypeNode } from 'regexpp2/src/const';\nimport rewritePattern from 'regexpu-core';\nimport regenerate from 'regenerate';\nimport { NodeBase, Pattern } from 'regexpp2/src/ast';\n\nexport { regenerate }\n\nexport interface IRegenerateObject extends regenerate.IRegenerateObject\n{\n\n\treadonly flags: string;\n\n\ttoStringOrigin(...options: Parameters<regenerate.IRegenerateObject[\"toString\"]>): ReturnType<regenerate.IRegenerateObject[\"toString\"]>;\n\n}\n\n/**\n * convert Specified type RegExp to hacked regenerate object\n *\n * @param {RegExp} re\n * @param {string} flags\n * @returns {regenerate.IRegenerateObject}\n */\nexport function regexpClassToObject(re: RegExp, flags?: string): IRegenerateObject\n{\n\tif (flags == null)\n\t{\n\t\tflags = re.flags;\n\t}\n\n\tconst hasUnicodeFlag = flags.includes('u');\n\n\tconst sourceOrigin = re.source;\n\n\tlet source = rewritePattern(sourceOrigin, flags, {\n\t\tunicodePropertyEscape: true,\n\t\tuseUnicodeFlag: hasUnicodeFlag,\n\t});\n\n\tlet ev = ParserEventEmitter.create(source, flags);\n\n\tlet new_obj: ReturnType<typeof regenerate>;\n\n\tev.on(ParserEventEmitterEvent.class, function (ast, eventName, ev, ...argv)\n\t{\n\t\tif (!isPattern(ast.parent) || ast.parent.elements.length != 1)\n\t\t{\n\t\t\tthrow new TypeError(`this regexp should only has class, but got ${source}`);\n\t\t}\n\n\t\tif (new_obj == null)\n\t\t{\n\t\t\tnew_obj = regenerate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new TypeError(`only allow one class, but got ${source}`);\n\t\t}\n\n\t\tast.elements.forEach(sub_ast => {\n\n\t\t\tswitch (sub_ast.type)\n\t\t\t{\n\t\t\t\tcase EnumTypeNode.CharacterClassRange:\n\t\t\t\t\tnew_obj.addRange(sub_ast.min.value, sub_ast.max.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EnumTypeNode.Character:\n\t\t\t\t\tnew_obj.add(sub_ast.value);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\n\t\t\t\t\tthrow new TypeError(`unknown ast ${JSON.stringify(sub_ast)}`);\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t});\n\n\t});\n\n\tev.resume();\n\n\tif (new_obj == null)\n\t{\n\t\tif (ev.astSource.elements.length == 1)\n\t\t{\n\t\t\tlet ast = ev.astSource.elements[0];\n\n\t\t\tif (ast.type === EnumTypeNode.Character)\n\t\t\t{\n\t\t\t\tnew_obj = regenerate();\n\n\t\t\t\tnew_obj.add(ast.value);\n\t\t\t}\n\t\t}\n\n\t\tif (new_obj == null)\n\t\t{\n\t\t\tthrow new TypeError(`not support ${ev}`);\n\t\t}\n\t}\n\n\treturn hackRegenerate(new_obj, flags, hasUnicodeFlag);\n}\n\nexport function hackRegenerate(obj: regenerate.IRegenerateObject, flags: string, hasUnicodeFlag: boolean): IRegenerateObject\n{\n\tObject.defineProperties(obj, {\n\n\t\tflags: {\n\t\t\tget()\n\t\t\t{\n\t\t\t\treturn flags;\n\t\t\t}\n\t\t},\n\n\t\ttoStringOrigin: {\n\t\t\tenumerable: false,\n\t\t\tvalue: regenerate.prototype.toString,\n\t\t},\n\n\t\ttoString: {\n\t\t\tenumerable: false,\n\n\t\t\tvalue: ((old) => {\n\n\t\t\t\treturn function (...options: Parameters<typeof obj.toString>)\n\t\t\t\t{\n\t\t\t\t\tif (options[0] == null)\n\t\t\t\t\t{\n\t\t\t\t\t\toptions[0] = {\n\t\t\t\t\t\t\thasUnicodeFlag,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tlet source: string = old.apply(this, options);\n\n\t\t\t\t\tif (!/^\\[.*\\]$/.test(source))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn `[${source}]`\n\t\t\t\t\t}\n\n\t\t\t\t\treturn source;\n\t\t\t\t}\n\n\t\t\t})(obj.toString),\n\t\t},\n\n\t\ttoRegExp: {\n\t\t\tenumerable: false,\n\n\t\t\tvalue: ((old) => {\n\n\t\t\t\treturn function (...options: Parameters<typeof obj.toRegExp>)\n\t\t\t\t{\n\t\t\t\t\tif (options[0] == null)\n\t\t\t\t\t{\n\t\t\t\t\t\toptions[0] = flags;\n\t\t\t\t\t}\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\treturn old.apply(this, options);\n\t\t\t\t}\n\n\t\t\t})(obj.toRegExp),\n\t\t},\n\n\t\tclone: {\n\t\t\tenumerable: false,\n\n\t\t\tvalue: ((old) => {\n\n\t\t\t\treturn function (...options)\n\t\t\t\t{\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tlet new_obj = old.apply(this, options);\n\n\t\t\t\t\treturn hackRegenerate(new_obj, flags, hasUnicodeFlag);\n\t\t\t\t}\n\n\t\t\t})(obj.clone),\n\t\t},\n\n\t});\n\n\treturn obj as IRegenerateObject\n}\n\nexport function isPattern(ast: NodeBase): ast is Pattern\n{\n\treturn (ast.type == EnumTypeNode.Pattern)\n}\n\nexport default regexpClassToObject\n\n\n"]}